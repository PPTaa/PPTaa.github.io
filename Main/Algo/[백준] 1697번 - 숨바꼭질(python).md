# [백준] 1697번 - **숨바꼭질** (python)

## 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

source : [문제링크 백준 - 1697](https://www.acmicpc.net/problem/1697)

## 내 코드

데이터의 저장과 반환을 간편하게 하기 위해 deque 라이브러리를 사용

너비우선 탐색 방식을 사용하여 하위 노드의 값과 찾아야하는 값을 비교하는 것으로 탐색

max는 문제에서 n, k의 값이 100,000 까지이므로 범위를 설정하기위해 설정

```python
from collections import deque
# 수빈이와 동생이 있을 수 있는 범위
Max = 100001
# 수빈이의 위치 n, 동생의 위치 k
n, k = map(int, input().split())
# 동적프로그래밍을 위한 array생성
array = [0] * Max

# 너비우선 탐색으로 시작
def bfs():
    q = deque([n])
    # q 가 없을때 까지 반복
    while q:
      	# q의 값을 왼쪽에서 부터 뽑아서 부모 노드라고 지정
        parent_node = q.popleft()
        # 뽑은 값이 동생의 위치라면 그 값의 array 값을 반환
        if parent_node == k:
            return array[parent_node]
        # 부모노드의 -1, +1, *2 값을 자식노드로 정하고 확인
        for child_node in (parent_node-1, parent_node+1, parent_node*2):
          	# 자식노드가 벗어나지 않았거나 자식노드의 값을 방문한 적이 없으면
            if 0 <= child_node < Max and not array[child_node]:
              	# 자식노드의 값에 부모노드의 값 + 1
                array[child_node] = array[parent_node] + 1
                # 자식노드를 q에 저장 
                q.append(child_node)
print(bfs())
```

ex)  n= 1, k=8 일 경우

array 시작

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

array 첫번째 반복

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

array 두번째 반복

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 2    | 2    | 0    | 0    | 0    | 0    | 0    |

array 세번째 반복

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 2    | 2    | 3    | 3    | 4    | 3    | 0    |

8은 3번째의 반복에 찾을 수 있다.
